{
  "version": 3,
  "sources": ["../../../worker.js"],
  "sourceRoot": "/Users/nicco/Antigravity Projects/cmpgvng/worker/.wrangler/tmp/deploy-5YPbsP",
  "sourcesContent": ["/**\n * CMP GVNG - Cloudflare Worker\n * Handles file uploads to OneDrive without requiring user authentication\n */\n\n// Constants\nconst GRAPH_API_BASE = \"https://graph.microsoft.com/v1.0\";\nconst TOKEN_ENDPOINT =\n  \"https://login.microsoftonline.com/common/oauth2/v2.0/token\";\nconst GOOGLE_DRIVE_API = \"https://www.googleapis.com/drive/v3\";\nconst CHUNK_SIZE = 5 * 1024 * 1024; // 5MB chunks for large files\n\n/**\n * Main request handler\n */\nexport default {\n  async fetch(request, env, ctx) {\n    // Handle CORS preflight\n    if (request.method === \"OPTIONS\") {\n      return handleCors(env);\n    }\n\n    // Add CORS headers to all responses\n    const corsHeaders = getCorsHeaders(env);\n\n    try {\n      const url = new URL(request.url);\n\n      // Health check endpoint\n      if (url.pathname === \"/health\") {\n        return new Response(\n          JSON.stringify({ status: \"ok\", timestamp: new Date().toISOString() }),\n          {\n            headers: { ...corsHeaders, \"Content-Type\": \"application/json\" },\n          }\n        );\n      }\n\n      // Upload endpoint\n      if (url.pathname === \"/upload\" && request.method === \"POST\") {\n        return await handleUpload(request, env, corsHeaders);\n      }\n\n      // Gallery endpoint - list files with thumbnails\n      if (url.pathname === \"/gallery\" && request.method === \"GET\") {\n        return await handleGallery(request, env, corsHeaders);\n      }\n\n      // Google Drive to OneDrive transfer endpoint\n      if (url.pathname === \"/upload-from-google\" && request.method === \"POST\") {\n        return await handleGoogleDriveUpload(request, env, corsHeaders);\n      }\n\n      // Google Photos to OneDrive transfer endpoint\n      if (\n        url.pathname === \"/upload-from-google-photos\" &&\n        request.method === \"POST\"\n      ) {\n        return await handleGooglePhotosUpload(request, env, corsHeaders);\n      }\n\n      // Photos Picker API Proxy - Create Session\n      if (url.pathname === \"/photos-session\" && request.method === \"POST\") {\n        return await proxyPhotosCreateSession(request, corsHeaders);\n      }\n\n      // Photos Picker API Proxy - Get Session Status or Items\n      if (\n        url.pathname.startsWith(\"/photos-session/\") &&\n        request.method === \"GET\"\n      ) {\n        // Parse: /photos-session/{sessionId} or /photos-session/{sessionId}/items\n        const pathParts = url.pathname\n          .replace(\"/photos-session/\", \"\")\n          .split(\"/\");\n        const sessionId = pathParts[0];\n        const action = pathParts[1]; // undefined or \"items\"\n\n        console.log(\n          \"Photos proxy route - sessionId:\",\n          sessionId,\n          \"action:\",\n          action\n        );\n\n        if (action === \"items\") {\n          return await proxyPhotosGetItems(request, sessionId, corsHeaders);\n        }\n        return await proxyPhotosGetSession(request, sessionId, corsHeaders);\n      }\n\n      // 404 for unknown routes\n      return new Response(JSON.stringify({ error: \"Not found\" }), {\n        status: 404,\n        headers: { ...corsHeaders, \"Content-Type\": \"application/json\" },\n      });\n    } catch (error) {\n      console.error(\"Worker error:\", error);\n      return new Response(JSON.stringify({ error: error.message }), {\n        status: 500,\n        headers: { ...corsHeaders, \"Content-Type\": \"application/json\" },\n      });\n    }\n  },\n};\n\n/**\n * Get CORS headers\n */\nfunction getCorsHeaders(env) {\n  return {\n    \"Access-Control-Allow-Origin\": env.CORS_ORIGIN || \"*\",\n    \"Access-Control-Allow-Methods\": \"GET, POST, OPTIONS\",\n    \"Access-Control-Allow-Headers\": \"Content-Type\",\n    \"Access-Control-Max-Age\": \"86400\",\n  };\n}\n\n/**\n * Handle CORS preflight requests\n */\nfunction handleCors(env) {\n  return new Response(null, {\n    status: 204,\n    headers: getCorsHeaders(env),\n  });\n}\n\n/**\n * Handle file upload\n */\nasync function handleUpload(request, env, corsHeaders) {\n  // Parse multipart form data\n  const formData = await request.formData();\n\n  // Verify password first\n  const password = formData.get(\"password\");\n  if (!password || password !== env.SITE_PASSWORD) {\n    return new Response(JSON.stringify({ error: \"Password non valida\" }), {\n      status: 401,\n      headers: { ...corsHeaders, \"Content-Type\": \"application/json\" },\n    });\n  }\n\n  const file = formData.get(\"file\");\n\n  if (!file) {\n    return new Response(JSON.stringify({ error: \"No file provided\" }), {\n      status: 400,\n      headers: { ...corsHeaders, \"Content-Type\": \"application/json\" },\n    });\n  }\n\n  // Validate file size\n  const maxSize = parseInt(env.MAX_FILE_SIZE_MB || \"500\") * 1024 * 1024;\n  if (file.size > maxSize) {\n    return new Response(\n      JSON.stringify({\n        error: `File too large. Max size: ${env.MAX_FILE_SIZE_MB}MB`,\n      }),\n      {\n        status: 400,\n        headers: { ...corsHeaders, \"Content-Type\": \"application/json\" },\n      }\n    );\n  }\n\n  // Get fresh access token\n  const accessToken = await getAccessToken(env);\n\n  // Sanitize filename\n  const fileName = sanitizeFileName(file.name);\n\n  // Upload to OneDrive\n  let result;\n  if (file.size < 4 * 1024 * 1024) {\n    // Small file - direct upload\n    result = await uploadSmallFile(file, fileName, accessToken, env);\n  } else {\n    // Large file - chunked upload\n    result = await uploadLargeFile(file, fileName, accessToken, env);\n  }\n\n  return new Response(\n    JSON.stringify({\n      success: true,\n      fileName: result.name,\n      size: result.size,\n      webUrl: result.webUrl,\n    }),\n    {\n      status: 200,\n      headers: { ...corsHeaders, \"Content-Type\": \"application/json\" },\n    }\n  );\n}\n\n/**\n * Get access token using refresh token\n */\nasync function getAccessToken(env) {\n  const response = await fetch(TOKEN_ENDPOINT, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/x-www-form-urlencoded\",\n    },\n    body: new URLSearchParams({\n      client_id: env.AZURE_CLIENT_ID,\n      client_secret: env.AZURE_CLIENT_SECRET,\n      refresh_token: env.AZURE_REFRESH_TOKEN,\n      grant_type: \"refresh_token\",\n      scope: \"https://graph.microsoft.com/Files.ReadWrite.All offline_access\",\n    }),\n  });\n\n  if (!response.ok) {\n    const error = await response.text();\n    console.error(\"Token refresh failed:\", error);\n    throw new Error(\"Failed to refresh access token\");\n  }\n\n  const data = await response.json();\n  return data.access_token;\n}\n\n/**\n * Upload small file (< 4MB) directly\n */\nasync function uploadSmallFile(file, fileName, accessToken, env) {\n  const uploadUrl = `${GRAPH_API_BASE}/drives/${env.ONEDRIVE_DRIVE_ID}/items/${env.ONEDRIVE_FOLDER_ID}:/${fileName}:/content`;\n\n  const response = await fetch(uploadUrl, {\n    method: \"PUT\",\n    headers: {\n      Authorization: `Bearer ${accessToken}`,\n      \"Content-Type\": file.type || \"application/octet-stream\",\n    },\n    body: file,\n  });\n\n  if (!response.ok) {\n    const error = await response.text();\n    console.error(\"Upload failed:\", error);\n    throw new Error(\"Failed to upload file\");\n  }\n\n  return await response.json();\n}\n\n/**\n * Upload large file using upload session (chunked)\n */\nasync function uploadLargeFile(file, fileName, accessToken, env) {\n  // Create upload session\n  const sessionUrl = `${GRAPH_API_BASE}/drives/${env.ONEDRIVE_DRIVE_ID}/items/${env.ONEDRIVE_FOLDER_ID}:/${fileName}:/createUploadSession`;\n\n  const sessionResponse = await fetch(sessionUrl, {\n    method: \"POST\",\n    headers: {\n      Authorization: `Bearer ${accessToken}`,\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      item: {\n        \"@microsoft.graph.conflictBehavior\": \"rename\",\n      },\n    }),\n  });\n\n  if (!sessionResponse.ok) {\n    const error = await sessionResponse.text();\n    console.error(\"Session creation failed:\", error);\n    throw new Error(\"Failed to create upload session\");\n  }\n\n  const session = await sessionResponse.json();\n  const uploadUrl = session.uploadUrl;\n\n  // Upload in chunks\n  // Optimization: Do NOT load entire file into memory. Slice blobs instead.\n  const fileSize = file.size;\n  let uploadedBytes = 0;\n  let result;\n\n  while (uploadedBytes < fileSize) {\n    const chunkStart = uploadedBytes;\n    const chunkEnd = Math.min(uploadedBytes + CHUNK_SIZE, fileSize);\n\n    // Slice only the needed chunk from the file blob\n    const chunkBlob = file.slice(chunkStart, chunkEnd);\n    const chunkArrayBuffer = await chunkBlob.arrayBuffer();\n\n    const chunkResponse = await fetch(uploadUrl, {\n      method: \"PUT\",\n      headers: {\n        \"Content-Length\": chunkArrayBuffer.byteLength.toString(),\n        \"Content-Range\": `bytes ${chunkStart}-${chunkEnd - 1}/${fileSize}`,\n      },\n      body: chunkArrayBuffer,\n    });\n\n    if (!chunkResponse.ok) {\n      const error = await chunkResponse.text();\n      console.error(\"Chunk upload failed:\", error);\n      throw new Error(\"Failed to upload file chunk\");\n    }\n\n    result = await chunkResponse.json();\n    uploadedBytes = chunkEnd;\n  }\n\n  return result;\n}\n\n/**\n * Sanitize filename for OneDrive\n */\nfunction sanitizeFileName(name) {\n  return name\n    .replace(/[\\\\/:*?\"<>|]/g, \"_\")\n    .replace(/\\s+/g, \" \")\n    .trim();\n}\n\n/**\n * Handle gallery request - list files with thumbnails\n */\nasync function handleGallery(request, env, corsHeaders) {\n  // Get password from query string\n  const url = new URL(request.url);\n  const password = url.searchParams.get(\"password\");\n\n  if (!password || password !== env.SITE_PASSWORD) {\n    return new Response(JSON.stringify({ error: \"Password non valida\" }), {\n      status: 401,\n      headers: { ...corsHeaders, \"Content-Type\": \"application/json\" },\n    });\n  }\n\n  // Get fresh access token\n  const accessToken = await getAccessToken(env);\n\n  // List files in the folder\n  // List files in the folder (fetch all pages)\n  let allItems = [];\n  let nextLink = `${GRAPH_API_BASE}/drives/${env.ONEDRIVE_DRIVE_ID}/items/${env.ONEDRIVE_FOLDER_ID}/children?$select=id,name,size,file,image,video,createdDateTime,@microsoft.graph.downloadUrl&$expand=thumbnails&$top=999`;\n\n  console.log(\"Starting gallery fetch...\");\n\n  while (nextLink) {\n    console.log(\"Fetching page:\", nextLink);\n    const response = await fetch(nextLink, {\n      headers: {\n        Authorization: `Bearer ${accessToken}`,\n      },\n    });\n\n    if (!response.ok) {\n      const error = await response.text();\n      console.error(\"List files failed:\", error);\n      throw new Error(\"Failed to list files\");\n    }\n\n    const data = await response.json();\n    if (data.value) {\n      allItems = allItems.concat(data.value);\n    }\n\n    nextLink = data[\"@odata.nextLink\"];\n  }\n\n  console.log(`Fetched total ${allItems.length} items`);\n\n  // Transform the response to just what we need\n  const items = allItems\n    .filter(\n      (item) =>\n        item.file &&\n        (item.file.mimeType.startsWith(\"image/\") ||\n          item.file.mimeType.startsWith(\"video/\"))\n    )\n    .map((item) => {\n      // Get thumbnail URL (prefer large, fallback to medium, then small)\n      let thumbnailUrl = null;\n      if (item.thumbnails && item.thumbnails.length > 0) {\n        const thumb = item.thumbnails[0];\n        thumbnailUrl =\n          thumb.large?.url || thumb.medium?.url || thumb.small?.url;\n      }\n\n      return {\n        id: item.id,\n        name: item.name,\n        size: item.size,\n        mimeType: item.file.mimeType,\n        isVideo: item.file.mimeType.startsWith(\"video/\"),\n        createdDateTime: item.createdDateTime,\n        thumbnailUrl: thumbnailUrl,\n        downloadUrl: item[\"@microsoft.graph.downloadUrl\"],\n        width: item.image?.width || item.video?.width,\n        height: item.image?.height || item.video?.height,\n      };\n    })\n    .sort((a, b) => new Date(b.createdDateTime) - new Date(a.createdDateTime)); // Newest first\n\n  return new Response(\n    JSON.stringify({\n      success: true,\n      count: items.length,\n      items: items,\n    }),\n    {\n      headers: { ...corsHeaders, \"Content-Type\": \"application/json\" },\n    }\n  );\n}\n\n/**\n * Handle Google Drive to OneDrive transfer\n */\nasync function handleGoogleDriveUpload(request, env, corsHeaders) {\n  const body = await request.json();\n  const { fileId, fileName, mimeType, googleAccessToken, password } = body;\n\n  // Verify password (can be passed in body or use session)\n  if (password && password !== env.SITE_PASSWORD) {\n    return new Response(JSON.stringify({ error: \"Password non valida\" }), {\n      status: 401,\n      headers: { ...corsHeaders, \"Content-Type\": \"application/json\" },\n    });\n  }\n\n  if (!fileId || !googleAccessToken) {\n    return new Response(\n      JSON.stringify({ error: \"Missing fileId or googleAccessToken\" }),\n      {\n        status: 400,\n        headers: { ...corsHeaders, \"Content-Type\": \"application/json\" },\n      }\n    );\n  }\n\n  try {\n    // Step 1: Download file from Google Drive\n    console.log(`Downloading file ${fileId} from Google Drive...`);\n\n    const googleFileResponse = await fetch(\n      `${GOOGLE_DRIVE_API}/files/${fileId}?alt=media`,\n      {\n        headers: {\n          Authorization: `Bearer ${googleAccessToken}`,\n        },\n      }\n    );\n\n    if (!googleFileResponse.ok) {\n      const error = await googleFileResponse.text();\n      console.error(\"Google Drive download failed:\", error);\n      throw new Error(\n        `Failed to download from Google Drive: ${googleFileResponse.status}`\n      );\n    }\n\n    // Step 2: Get file content\n    const fileContent = await googleFileResponse.arrayBuffer();\n    const fileSize = fileContent.byteLength;\n\n    console.log(`Downloaded ${fileSize} bytes. Uploading to OneDrive...`);\n\n    // Step 3: Get OneDrive access token\n    const oneDriveToken = await getAccessToken(env);\n\n    // Step 4: Sanitize filename\n    const sanitizedName = sanitizeFileName(fileName || `file_${fileId}`);\n\n    // Step 5: Upload to OneDrive\n    let result;\n    if (fileSize < 4 * 1024 * 1024) {\n      // Small file - direct upload\n      result = await uploadSmallFileFromBuffer(\n        fileContent,\n        sanitizedName,\n        mimeType,\n        oneDriveToken,\n        env\n      );\n    } else {\n      // Large file - chunked upload\n      result = await uploadLargeFileFromBuffer(\n        fileContent,\n        sanitizedName,\n        oneDriveToken,\n        env\n      );\n    }\n\n    return new Response(\n      JSON.stringify({\n        success: true,\n        fileName: result.name,\n        size: result.size,\n        webUrl: result.webUrl,\n        source: \"google-drive\",\n      }),\n      {\n        status: 200,\n        headers: { ...corsHeaders, \"Content-Type\": \"application/json\" },\n      }\n    );\n  } catch (error) {\n    console.error(\"Google Drive transfer error:\", error);\n    return new Response(\n      JSON.stringify({ error: error.message || \"Transfer failed\" }),\n      {\n        status: 500,\n        headers: { ...corsHeaders, \"Content-Type\": \"application/json\" },\n      }\n    );\n  }\n}\n\n/**\n * Upload small file from ArrayBuffer (<4MB)\n */\nasync function uploadSmallFileFromBuffer(\n  buffer,\n  fileName,\n  mimeType,\n  accessToken,\n  env\n) {\n  const uploadUrl = `${GRAPH_API_BASE}/drives/${env.ONEDRIVE_DRIVE_ID}/items/${env.ONEDRIVE_FOLDER_ID}:/${fileName}:/content`;\n\n  const response = await fetch(uploadUrl, {\n    method: \"PUT\",\n    headers: {\n      Authorization: `Bearer ${accessToken}`,\n      \"Content-Type\": mimeType || \"application/octet-stream\",\n    },\n    body: buffer,\n  });\n\n  if (!response.ok) {\n    const error = await response.text();\n    console.error(\"Upload failed:\", error);\n    throw new Error(\"Failed to upload file to OneDrive\");\n  }\n\n  return await response.json();\n}\n\n/**\n * Upload large file from ArrayBuffer using chunked upload\n */\nasync function uploadLargeFileFromBuffer(buffer, fileName, accessToken, env) {\n  // Create upload session\n  const sessionUrl = `${GRAPH_API_BASE}/drives/${env.ONEDRIVE_DRIVE_ID}/items/${env.ONEDRIVE_FOLDER_ID}:/${fileName}:/createUploadSession`;\n\n  const sessionResponse = await fetch(sessionUrl, {\n    method: \"POST\",\n    headers: {\n      Authorization: `Bearer ${accessToken}`,\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      item: {\n        \"@microsoft.graph.conflictBehavior\": \"rename\",\n      },\n    }),\n  });\n\n  if (!sessionResponse.ok) {\n    const error = await sessionResponse.text();\n    console.error(\"Session creation failed:\", error);\n    throw new Error(\"Failed to create upload session\");\n  }\n\n  const session = await sessionResponse.json();\n  const uploadUrl = session.uploadUrl;\n\n  // Upload in chunks\n  const fileSize = buffer.byteLength;\n  let uploadedBytes = 0;\n  let result;\n\n  while (uploadedBytes < fileSize) {\n    const chunkStart = uploadedBytes;\n    const chunkEnd = Math.min(uploadedBytes + CHUNK_SIZE, fileSize);\n    const chunk = buffer.slice(chunkStart, chunkEnd);\n\n    const chunkResponse = await fetch(uploadUrl, {\n      method: \"PUT\",\n      headers: {\n        \"Content-Length\": chunk.byteLength.toString(),\n        \"Content-Range\": `bytes ${chunkStart}-${chunkEnd - 1}/${fileSize}`,\n      },\n      body: chunk,\n    });\n\n    if (!chunkResponse.ok) {\n      const error = await chunkResponse.text();\n      console.error(\"Chunk upload failed:\", error);\n      throw new Error(\"Failed to upload file chunk\");\n    }\n\n    result = await chunkResponse.json();\n    uploadedBytes = chunkEnd;\n  }\n\n  return result;\n}\n\n/**\n * Handle Google Photos to OneDrive transfer\n */\nasync function handleGooglePhotosUpload(request, env, corsHeaders) {\n  const body = await request.json();\n  const { mediaItemId, fileName, mimeType, baseUrl, googleAccessToken } = body;\n\n  if (!baseUrl || !googleAccessToken) {\n    return new Response(\n      JSON.stringify({ error: \"Missing baseUrl or googleAccessToken\" }),\n      {\n        status: 400,\n        headers: { ...corsHeaders, \"Content-Type\": \"application/json\" },\n      }\n    );\n  }\n\n  try {\n    // Step 1: Download photo from Google Photos\n    // For photos, append =d to get full resolution download\n    const downloadUrl = baseUrl.includes(\"?\") ? `${baseUrl}&d` : `${baseUrl}=d`;\n\n    console.log(`Downloading from Google Photos: ${mediaItemId}`);\n\n    const photoResponse = await fetch(downloadUrl, {\n      headers: {\n        Authorization: `Bearer ${googleAccessToken}`,\n      },\n    });\n\n    if (!photoResponse.ok) {\n      const error = await photoResponse.text();\n      console.error(\"Google Photos download failed:\", error);\n      throw new Error(\n        `Failed to download from Google Photos: ${photoResponse.status}`\n      );\n    }\n\n    // Step 2: Get file content\n    const fileContent = await photoResponse.arrayBuffer();\n    const fileSize = fileContent.byteLength;\n\n    console.log(`Downloaded ${fileSize} bytes. Uploading to OneDrive...`);\n\n    // Step 3: Get OneDrive access token\n    const oneDriveToken = await getAccessToken(env);\n\n    // Step 4: Sanitize filename\n    const sanitizedName = sanitizeFileName(\n      fileName || `photo_${mediaItemId}.jpg`\n    );\n\n    // Step 5: Upload to OneDrive\n    let result;\n    if (fileSize < 4 * 1024 * 1024) {\n      result = await uploadSmallFileFromBuffer(\n        fileContent,\n        sanitizedName,\n        mimeType || \"image/jpeg\",\n        oneDriveToken,\n        env\n      );\n    } else {\n      result = await uploadLargeFileFromBuffer(\n        fileContent,\n        sanitizedName,\n        oneDriveToken,\n        env\n      );\n    }\n\n    return new Response(\n      JSON.stringify({\n        success: true,\n        fileName: result.name,\n        size: result.size,\n        webUrl: result.webUrl,\n        source: \"google-photos\",\n      }),\n      {\n        status: 200,\n        headers: { ...corsHeaders, \"Content-Type\": \"application/json\" },\n      }\n    );\n  } catch (error) {\n    console.error(\"Google Photos transfer error:\", error);\n    return new Response(\n      JSON.stringify({ error: error.message || \"Transfer failed\" }),\n      {\n        status: 500,\n        headers: { ...corsHeaders, \"Content-Type\": \"application/json\" },\n      }\n    );\n  }\n}\n\n/**\n * Proxy: Create Photos Picker session\n */\nasync function proxyPhotosCreateSession(request, corsHeaders) {\n  const body = await request.json();\n  const { accessToken } = body;\n\n  if (!accessToken) {\n    return new Response(JSON.stringify({ error: \"Missing accessToken\" }), {\n      status: 400,\n      headers: { ...corsHeaders, \"Content-Type\": \"application/json\" },\n    });\n  }\n\n  const response = await fetch(\n    \"https://photospicker.googleapis.com/v1/sessions\",\n    {\n      method: \"POST\",\n      headers: {\n        Authorization: `Bearer ${accessToken}`,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({}),\n    }\n  );\n\n  const data = await response.json();\n  return new Response(JSON.stringify(data), {\n    status: response.status,\n    headers: { ...corsHeaders, \"Content-Type\": \"application/json\" },\n  });\n}\n\n/**\n * Proxy: Get Photos Picker session status\n */\nasync function proxyPhotosGetSession(request, sessionId, corsHeaders) {\n  const url = new URL(request.url);\n  const accessToken = url.searchParams.get(\"accessToken\");\n\n  if (!accessToken) {\n    return new Response(JSON.stringify({ error: \"Missing accessToken\" }), {\n      status: 400,\n      headers: { ...corsHeaders, \"Content-Type\": \"application/json\" },\n    });\n  }\n\n  const response = await fetch(\n    `https://photospicker.googleapis.com/v1/sessions/${sessionId}`,\n    {\n      headers: {\n        Authorization: `Bearer ${accessToken}`,\n      },\n    }\n  );\n\n  const data = await response.json();\n  return new Response(JSON.stringify(data), {\n    status: response.status,\n    headers: { ...corsHeaders, \"Content-Type\": \"application/json\" },\n  });\n}\n\n/**\n * Proxy: Get Photos Picker selected items\n */\nasync function proxyPhotosGetItems(request, sessionId, corsHeaders) {\n  const url = new URL(request.url);\n  const accessToken = url.searchParams.get(\"accessToken\");\n\n  if (!accessToken) {\n    return new Response(JSON.stringify({ error: \"Missing accessToken\" }), {\n      status: 400,\n      headers: { ...corsHeaders, \"Content-Type\": \"application/json\" },\n    });\n  }\n\n  try {\n    console.log(\"proxyPhotosGetItems called - sessionId:\", sessionId);\n\n    const response = await fetch(\n      `https://photospicker.googleapis.com/v1/sessions/${sessionId}/mediaItems`,\n      {\n        headers: {\n          Authorization: `Bearer ${accessToken}`,\n        },\n      }\n    );\n\n    console.log(\"Photos API mediaItems response status:\", response.status);\n\n    // Get response as text first to handle non-JSON responses\n    const responseText = await response.text();\n\n    // Try to parse as JSON\n    let data;\n    try {\n      data = JSON.parse(responseText);\n    } catch (parseError) {\n      console.error(\n        \"Failed to parse Photos API response as JSON:\",\n        responseText.substring(0, 200)\n      );\n      return new Response(\n        JSON.stringify({\n          error: \"Invalid response from Google Photos API\",\n          details: responseText.substring(0, 200),\n        }),\n        {\n          status: 500,\n          headers: { ...corsHeaders, \"Content-Type\": \"application/json\" },\n        }\n      );\n    }\n\n    return new Response(JSON.stringify(data), {\n      status: response.status,\n      headers: { ...corsHeaders, \"Content-Type\": \"application/json\" },\n    });\n  } catch (error) {\n    console.error(\"proxyPhotosGetItems error:\", error);\n    return new Response(\n      JSON.stringify({ error: error.message || \"Unknown error in proxy\" }),\n      {\n        status: 500,\n        headers: { ...corsHeaders, \"Content-Type\": \"application/json\" },\n      }\n    );\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
